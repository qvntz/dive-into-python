## Задачи на этой неделе:
1. [Реализация простого класса для чтения из файла](https://github.com/qvntz/dive-into-python/blob/main/week3/ex1.py) 
    <br/>Первое задание на этой неделе — не сложное, для разогрева. 
   Ваша задача: написать python-модуль ***solution.py***, внутрь которого необходимо поместить 
   код класса ***FileReader***. Конструктор этого класса принимает один параметр: путь до файла на диске. 
   В классе ***FileReader*** должен быть реализован метод **read**, возвращающий строку - содержимое файла, 
   путь к которому был указан при создании экземпляра класса. Python модуль должен быть написан
   таким образом, чтобы импорт класса ***FileReader*** из него не вызвал ошибок.
   <br/><br/>При написании реализации метода **read**, вам нужно учитывать случай, когда при инициализации 
   был передан путь к несуществующему файлу. Требуется обработать возникающее при этом 
   исключение ***FileNotFoundError*** и вернуть из метода read пустую строку.
   <br/><br/>Пример работы:
   ```
   >>> from solution import FileReader
   >>> reader = FileReader('not_exist_file.txt')
   >>> text = reader.read()
   >>> text
   ''
   >>> with open('some_file.txt', 'w') as file:
   ...     file.write('some text')
   ...
   9
   >>> reader = FileReader('some_file.txt')
   >>> text = reader.read()
   >>> text
   'some text'
   >>> type(reader)
   <class 'solution.FileReader'>  
   ```

2. [Классы и наследование](https://github.com/qvntz/dive-into-python/blob/main/week3/ex2.py)
   <br/>Как правило задачи про классы не носят вычислительный характер. Обычно нужно написать классы, 
   которые отвечают определенным интерфейсам. Насколько удобны эти интерфейсы и как сильно связаны 
   классы между собой, определит легкость их использования в будущих программах. 
   <br/><br/>Предположим есть данные о разных автомобилях и спецтехнике. 
   Данные представлены в виде таблицы с характеристиками. 
   Вся техника разделена на три вида: спецтехника, легковые и грузовые автомобили. 
   Обратите внимание на то, что некоторые характеристики присущи только определенному виду техники. 
   Например, у легковых автомобилей есть характеристика «кол-во пассажирских мест», 
   а у грузовых автомобилей — габариты кузова: «длина», «ширина» и «высота».
   
    | Тип (car type) | Марка (brand) | Кол-во пассажирских мест | Фото (photo_file_name) | Кузов ДхШхВ, м (body_whl) | Грузоподъемность, Тонн (carrying) | Дополнительно (extra) |
    | :-------------: | :-------------: |:-------------:| :-----:| :-------------: | :-------------: | :-------------: |
    | car | Nissan xTrail | 4 | f1.jpeg |  | 2.5 | | 
    | truck | Man |  | f2.jpeg | 8x3x2.5 | 20 | |
    | car | Mazda 6 | 4 | f3.jpeg |  | 2.5 | |
    | spec_machine | Hitachi |  | f4.jpeg |  | 1.2 | Легкая техника для уборки снега |

   <br/><br/>
   Вам необходимо создать свою иерархию классов для данных, которые описаны в таблице. 
   Классы должны называться CarBase (базовый класс для всех типов машин), 
   Car (легковые автомобили), Truck (грузовые автомобили) и SpecMachine (спецтехника). 
   Все объекты имеют обязательные атрибуты:

    - car_type, значение типа объекта и может принимать одно из значений: «car», «truck», «spec_machine».

    - photo_file_name, имя файла с изображением машины, допустимы названия файлов изображений с расширением из списка: «.jpg», «.jpeg», «.png», «.gif»

    - brand, марка производителя машины

    - carrying, грузоподъемность

    <br/>В базовом классе CarBase нужно реализовать метод get_photo_file_ext для получения 
   расширения файла изображения. Расширение файла можно получить при помощи os.path.splitext.

    <br/>Для грузового автомобиля необходимо в конструкторе класса определить атрибуты: 
   body_length, body_width, body_height, отвечающие соответственно за габариты кузова — длину,
   ширину и высоту. Габариты передаются в параметре body_whl (строка, в которой размеры 
   разделены латинской буквой «x»). Обратите внимание на то, что характеристики кузова должны быть
   вещественными числами и характеристики кузова могут быть не валидными (например, пустая строка).
   В таком случае всем атрибутам, отвечающим за габариты кузова, присваивается значение равное нулю.

   <br/>Также для класса грузового автомобиля необходимо реализовать метод get_body_volume, 
   возвращающий объем кузова.

    <br/>В классе Car должен быть определен атрибут passenger_seats_count (количество пассажирских мест),
   а в классе SpecMachine — extra (дополнительное описание машины).

    <br/>Полная информация о атрибутах классов приведена в таблице ниже, где 1 - означает, 
   что атрибут обязателен для объекта, 0 - атрибут должен отсутствовать.
   
    |               | Car | Truck | SpecMachine |
    | ------------- | ------------- |:-------------:| -----:|
    |car type| 1 | 1 | 1 | 
    |photo_file_name| 1 | 1 | 1 | 
    |brand| 1 | 1 | 1 |
    |carrying| 1 | 1 | 1 |
    |passenger_seats_count| 1 | 0 | 0 |
    |body_width| 0 | 1 | 0 |
    |body_height| 0 | 1 | 0 |
    |body_length| 0 | 1 | 0 |
    |extra| 0 | 0 | 1 |

    Обратите внимание, что у каждого объекта из иерархии должен быть свой набор атрибутов
    и методов. Например, у класса легковой автомобиль не должно быть 
    метода **get_body_volume** в отличие от класса грузового автомобиля. 
    Имена атрибутов и методов должны совпадать с теми, что описаны выше.

   <br/>Далее вам необходимо реализовать функцию **get_car_list**, на вход которой 
   подается имя файла в формате ***csv***. Файл содержит данные, аналогичные строкам из таблицы.
   Вам необходимо прочитать этот файл построчно при помощи модуля стандартной 
   библиотеки ***csv***. Затем проанализировать строки на валидность и создать 
   список объектов с автомобилями и специальной техникой. Функция должна возвращать
   список объектов.
   
   <br/>Первая строка в исходном файле — это заголовок ***csv***, который содержит имена колонок.
   Нужно пропустить первую строку из исходного файла. Обратите внимание на то,
   что в некоторых строках исходного файла, данные могут быть заполнены некорректно,
   например, отсутствовать обязательные поля или иметь не валидное значение.
   В таком случае нужно проигнорировать подобные строки и не создавать объекты.
   Строки с пустым или не валидным значением для ***body_whl*** игнорироваться не должны.
   Вы можете использовать стандартный механизм обработки исключений в процессе чтения,
   валидации и создания объектов из строк csv-файла. Проверьте работу вашего кода 
   с входным файлом, прежде чем загружать задание для оценки.

    Пример кода, демонстрирующего чтение csv файла:
   ```
   import csv
   with open(csv_filename) as csv_fd:
   reader = csv.reader(csv_fd, delimiter=';')
   next(reader)  # пропускаем заголовок
   for row in reader:
       print(row)
   ```
   Ниже приведен шаблон кода для выполнения задания:
    ```
   class CarBase:
   def __init__(self, brand, photo_file_name, carrying):
       pass
   
   class Car(CarBase):
   def __init__(self, brand, photo_file_name, carrying, passenger_seats_count):
       pass
   
   class Truck(CarBase):
   def __init__(self, brand, photo_file_name, carrying, body_whl):
       pass


   class SpecMachine(CarBase):
   def __init__(self, brand, photo_file_name, carrying, extra):
       pass


   def get_car_list(csv_filename):
       car_list = []
       return car_list
    ```